# 设计文档

## 参考编译器介绍

## 编译器总体设计

**注：文档中列出的类的方法，主要为了体现设计思想，可能并不完整，具体参见源代码**

## 词法分析设计

### 编码前的设计

词法分析器作为编译器的第一部分，承担的任务就是通过扫描输入的源程序字符串，将其分割成一个个单词，同时记录这些单词的类别信息。利用面向对象的思想，可以抽象出`Word`类代表单词，枚举类`TokenType`表示单词类别,除去`Ident`,`IntConst`,`FormatString`，可以分为`Reserved`和`Frontend.Semantic.Symbols.Symbols`。

```java
public class Word {
    private final String token;		//单词值
    private final TokenType type;	//单词类别
    private final int line;			//行号

    public Word(String token, TokenType type, int line) {
        this.token = token;
        this.type = type;
        this.line = line;
    }
}

package Frontend.Lexical;

public enum TokenType {
    IDENFR,
    INTCON,
    STRCON,
    //RESERVED
    MAINTK,
    CONSTTK,
    INTTK,
    VOIDTK,
    BREAKTK,
    CONTINUETK,
    IFTK,
    ELSETK,
    FORTK,
    GETINTTK,
    PRINTFTK,
    RETURNTK,
    //SYMBOL
    NOT,
    AND,
    OR,
    PLUS,
    MINU,
    MULT,
    DIV,
    MOD,
    LSS,
    LEQ,
    GRE,
    GEQ,
    EQL,
    NEQ,
    ASSIGN,
    SEMICN,
    COMMA,
    LPARENT,
    RPARENT,
    LBRACK,
    RBRACK,
    LBRACE,
    RBRACE,
}
```

考虑如何读入，因为需要记录单词所在行信息，故采取按行读入，再拼接到一个字符串中。

```java
BufferedReader br = new BufferedReader(new FileReader("testfile.txt"));
String str = br.readLine();
StringBuilder article = new StringBuilder();
while(str != null) {
	article.append(str);
    article.append('\n');
    str = br.readLine();
}
```

从文章中分离出一个个词，本质是一个有限状态自动机，主要流程如下图所示：
![image-20230917154339637](C:\Users\legion\AppData\Roaming\Typora\typora-user-images\image-20230917154339637.png)

当识别到一个`Token`时，需要与`TokenType`中的类型相对应，故将除`Ident`,`IntConst`,`FormatString`外的`Reserved`和`Frontend.Semantic.Symbols.Symbols`建立`HashMap`方便查询。

```java
public static final HashMap<String, TokenType> reserved = new HashMap<>(){{
        put("main", TokenType.MAINTK);
        put("const", TokenType.CONSTTK);
        put("int", TokenType.INTTK);
        put("void", TokenType.VOIDTK);
        put("break", TokenType.BREAKTK);
        put("continue", TokenType.CONTINUETK);
        put("if", TokenType.IFTK);
        put("else", TokenType.ELSETK);
        put("for", TokenType.FORTK);
        put("getint", TokenType.GETINTTK);
        put("printf", TokenType.PRINTFTK);
        put("return", TokenType.RETURNTK);
    }};

    public static final HashMap<String, TokenType> symbols = new HashMap<>(){{
        put("!", TokenType.NOT);
        put("&&", TokenType.AND);
        put("||", TokenType.OR);
        put("+", TokenType.PLUS);
        put("-", TokenType.MINU);
        put("*", TokenType.MULT);
        put("/", TokenType.DIV);
        put("%", TokenType.MOD);
        put("<", TokenType.LSS);
        put("<=", TokenType.LEQ);
        put(">", TokenType.GRE);
        put(">=", TokenType.GEQ);
        put("==", TokenType.EQL);
        put("!=", TokenType.NEQ);
        put("=", TokenType.ASSIGN);
        put(";", TokenType.SEMICN);
        put(",", TokenType.COMMA);
        put("(", TokenType.LPARENT);
        put(")", TokenType.RPARENT);
        put("[", TokenType.LBRACK);
        put("]", TokenType.RBRACK);
        put("{", TokenType.LBRACE);
        put("}", TokenType.RBRACE);
    }};
```

以识别到`Reserved`或`Ident`为例，将`token`从`str`中分类出来，并新建一个`word`对象保存到`TokenList`中。

```java
else if(Character.isLetter(cur) || cur == '_') {
                int start = pos;
                while(pos < len && (Character.isLetter(str.charAt(pos)) || Character.isDigit(str.charAt(pos)) || str.charAt(pos) == '_')) {
                    pos++;
                }
                int end = pos;
                String token = str.substring(start, end);
                Word word = new Word(token, reserved.getOrDefault(token, TokenType.IDENFR), line);
                TokenList.add(word);
            }
```

### 编码完成之后的修改

暂无。

## 语法分析设计

### 编码前的设计

语法分析，要对词法分析中得到的单词根据给定的文法进行进一步地分析，将其建立成结构化的语法树。不难看出，题目要求的输出顺序即是对语法树的后序遍历，所以这里只要考虑如何建立语法树即可。

既然要建立语法树，就需要有树的结点，由此得到了一个抽象类`ASTNode`，具有一个抽象方法`print`以便输出。

```java
public abstract class ASTNode {
    public abstract void print();
}
```

我们知道，树的结点可以分为叶子结点和非叶子结点，由此又得到了继承`ASTNode`的两个抽象类`Terminal`和`non_Terminal`，分别代表终结符和非终结符。

```java
public abstract class Terminal extends ASTNode {
    Word word;
    public void print() {
        System.out.println(word.getType() + " " + word.getToken());
    }
}
```

语法分析主要采用**递归下降**的思想。递归下降的主要思路，就是为每个语法成分都编写一个子程序，该子程序会调用其他的子程序来解析组成该语法成分的其他语法成分，即对应到这里的抽象方法`analyse()`，文法中出现的非终结符都会继承`non_Terminal`类，也将继承这个方法。

```java
public abstract class non_Terminal extends ASTNode {
    
    public abstract void analyse();
    
    ArrayList<ASTNode> child = new ArrayList<>();		//子结点
    
    public ArrayList<ASTNode> getChild() {
        return child;
    }
    
    public void addChild(ASTNode node) {
        child.add(node);
    }
    
    public ASTNode removeChild() {
        return child.remove(child.size() - 1);
    }
    
    public void add_analyse(non_Terminal node) {
        child.add(node);
        node.analyse();
    }
    
    //后序遍历
    public void print() {
        for(ASTNode node: getChild()) {
            node.print();
        }
        System.out.println("<"+this.getClass().getSimpleName()+">");
    }
}
```

以`ConstDecl`的分析为例,	`ConstDecl → 'const' BType ConstDef { ',' ConstDef } ';'`

```java
public class ConstDecl extends non_Terminal {
    public void analyse() {
        if(cur_equal("const")) {
            addChild(new Reserved(cur));
            next();
            if(cur_equal("int")) {
                addChild(new Reserved(cur));
                next();
                add_analyse(new ConstDef());
                while(cur_equal(",")) {
                    addChild(new Frontend.Semantic.Symbols.Symbols(cur));
                    next();
                    add_analyse(new ConstDef());
                }
                if(cur_equal(";")) {
                    addChild(new Frontend.Semantic.Symbols.Symbols(cur));
                    next();
                }
            }
        }
    }
}

```

解释一下上述代码中出现的方法，具体实现参见源代码。

- `add_child()`：将该结点添加到当前结点的子结点中。
- `next()`:  读取下一个单词。
- `cur_eaqul()`: 判断当前单词与对于字符串是否相同。
- `add_analyse()`: 本质上是`addChild()`和`analyse()`，为了简洁就合并为一个方法。（其实`addChild()`和`next()`也可以合并，但逻辑上并无直接联系，~~且本人很懒~~，故作罢）。

### 编码完成之后的修改

因为存在左递归文法（如`AddExp`)，实际处理时需要改写文法，但又要保证输出顺序不变，故需要将已添加的子结点取下接到真正的父结点上。

```java
public class AddExp extends non_Terminal {
    @Override
    public void analyse() {
        if(cur_equal("(")||cur_equal("+")||cur_equal("-")||cur_equal("!")||isIdent(cur)|| isIntConst(cur))
        {
            add_analyse(new MulExp());
            while (cur_equal("+")||cur_equal("-"))
            {
                MulExp a = (MulExp) this.removeChild();
                AddExp addExp = new AddExp();
                addExp.addChild(a);
                addChild(addExp);
                addChild(new Frontend.Semantic.Symbols.Symbols(cur));
                next();
                add_analyse(new MulExp());
            }
        }
    }
}
```

## 错误处理设计

### 编码前的设计

### 编码完成之后的修改

## 代码生成设计

### 编码前的设计

### 编码完成之后的修改

## 代码优化设计

### 编码前的设计

### 编码完成之后的修改